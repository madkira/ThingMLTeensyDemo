thing Communication includes eblinker , SoftButtonMsgs { required port Blinker { sends erreur } required port Button { receives click receives double_click receives long_press } statechart Main init Idle { state Idle { internal event m : Button ? click action do end internal event m : Button ? double_click action do Blinker ! erreur ( 12 ) end internal event m : Button ? long_press action Blinker ! erreur ( 3 ) } } } thing fragment iblinker { message blink ( ) message enderreur ( ) } thing fragment eblinker { message erreur ( id : UInt8 ) } thing fragment iSoftButton { message timer_timeout ( ) } thing fragment SoftButtonMsgs { message click ( ) message double_click ( ) message long_press ( ) } thing Seriala includes eblinker { provided port basic { receives erreur } statechart Message init Idle { on entry do 'Serial.begin(115200);' end state Idle { internal event m : basic ? erreur action 'Serial.println("Error obtain ");Serial.println((int)' & m . id & ');' } } } thing SoftButton includes ButtonMsgs , iSoftButton , SoftButtonMsgs @c_header "#include <Timer.h>" @c_global "extern struct SoftButton_Instance softButton_var;" { required port Button { receives press receives release } internal port Timer { sends timer_timeout receives timer_timeout } provided port SoftButton { sends click sends double_click sends long_press } readonly property long_delay : UInt16 = 1000 readonly property double_delay : UInt16 = 250 function timeout_button ( ) @c_prototype "void timeout_button()" do 'SoftButton_send_Timer_timer_timeout(&softButton_var);' end statechart SoftButtonImpl init Idle { state Idle { transition pressed -> Pressed event m : Button ? press } state Pressed { on entry 'start_timer(1, ' & long_delay & ', &timeout_button);' on exit 'timer_cancel(1);' transition long -> Idle event Timer ? timer_timeout action SoftButton ! long_press ( ) transition click -> Released event Button ? release } state Released { on entry 'start_timer(1, ' & double_delay & ', &timeout_button);' on exit 'timer_cancel(1);' transition click -> Idle event Timer ? timer_timeout action SoftButton ! click ( ) transition double -> Idle event Button ? press action SoftButton ! double_click ( ) } } } thing Blinker includes iblinker , eblinker @c_header "#include <morse_code.h>
" @c_global "
#define MORSE_UNIT 200000
extern struct Blinker_Instance blinker_var;
IntervalTimer blink_timer;
boolean current_blink = HIGH;
" { internal port evt { sends blink sends enderreur receives blink receives enderreur } provided port err { receives erreur } function timer_message ( time : UInt32 ) do 'blink_timer.begin(&callback_message, ' & time & '*MORSE_UNIT);' end function callback_message ( ) @c_prototype "void callback_message()" do '
		Blinker_send_evt_blink(&blinker_var);' end statechart BlinkerState init Idle { on entry do 'pinMode(13, OUTPUT);
    				blink_timer = IntervalTimer();' end state Idle { on entry do 'digitalWriteFast(13, HIGH);' end transition errors -> errBegin event m : err ? erreur action do 'set_code(' & m . id & ');' end } state errBegin { on entry do 'digitalWriteFast(13, LOW);
    			current_blink = HIGH;' timer_message ( 20 ) end transition errors -> Message event m : evt ? blink } state Message { on entry do 'digitalWriteFast(13, current_blink);
        		current_blink = (current_blink == HIGH)? LOW : HIGH;' 'uint8_t val = get_time();' if ( 'val' == 0 ) do 'reset();' evt ! enderreur ( ) end else do timer_message ( 'val' ) end end transition errors -> Message event m : evt ? blink transition blink -> Idle event m : evt ? enderreur } } } datatype Char < 1 > @type_checker "Integer" @c_type "char" @c_byte_size "1" object String @type_checker "String" @c_type "char *" @c_byte_size "2" datatype Boolean < 1 > @type_checker "Boolean" @c_type "uint8_t" @c_byte_size "1" datatype UInt8 < 1 > @type_checker "Integer" @c_type "uint8_t" @c_byte_size "1" datatype UInt16 < 2 > @type_checker "Integer" @c_type "uint16_t" @c_byte_size "2" @java_type "int" @java_primitive "true" datatype Int16 < 2 > @type_checker "Integer" @c_type "int16_t" @c_byte_size "2" datatype UInt32 < 4 > @type_checker "Integer" @c_type "uint32_t" @c_byte_size "4" datatype Integer < 2 > @type_checker "Integer" @c_type "int16_t" @c_byte_size "2" datatype Long < 4 > @type_checker "Integer" @c_type "long" @c_byte_size "4" datatype Float < 4 > @type_checker "Real" @c_type "float" @c_byte_size "4" enumeration DigitalState @c_byte_size "1" @c_type "uint8_t" { LOW @enum_val "0" HIGH @enum_val "1" } datatype Byte < 1 > @type_checker "Integer" @c_type "uint8_t" @c_byte_size "1" @java_type "byte" @java_primitive "true" @scala_type "Byte" @SenML_type "Double" enumeration DigitalState @c_type "uint8_t" @c_byte_size "1" { LOW @enum_val "0" HIGH @enum_val "1" } thing fragment TimerMsgs { message timer_start ( id : UInt8 , time : UInt32 ) @timer_start "true" message timer_cancel ( id : UInt8 ) @timer_cancel "true" message timer_timeout ( id : UInt8 ) @timeout "true" message ms25_tic ( ) @xms_tic "25" message ms500_tic ( ) @xms_tic "500" } thing fragment ButtonMsgs { message press ( ) message release ( ) } thing fragment TimerMessages { message ms25_tic ( ) } thing Button includes ButtonMsgs , TimerMessages @c_header "#include <Timer.h>" @c_global "extern struct Button_Instance button_var;" { internal port clock { sends ms25_tic receives ms25_tic } provided port evt { sends press sends release } property PIN : UInt8 = 7 function is_pressed ( ) : Boolean do return '1 - digitalRead(' & PIN & ')' end function time_25ms ( ) @c_prototype "void time_25ms()" do 'Button_send_clock_ms25_tic(&button_var);' 'start_timer(0, 25, &time_25ms);' end statechart Button init RELEASED { on entry do 'pinMode(' & PIN & ', INPUT_PULLUP);
			start_timer(0, 125, &time_25ms);' end state RELEASED { transition status -> PRESSED event clock ? ms25_tic guard is_pressed ( ) action evt ! press ( ) } state PRESSED { transition status -> RELEASED event clock ? ms25_tic guard not is_pressed ( ) action evt ! release ( ) } } } configuration Teensy { instance button : Button instance softButton : SoftButton instance blinker : Blinker instance seriala : Seriala instance communication : Communication connector softButton . Button => button . evt connector communication . Blinker => blinker . err connector communication . Blinker => seriala . basic connector communication . Button => softButton . SoftButton }